# BUD - ãƒ­ã‚°è¨­è¨ˆãƒ»é‹ç”¨ã‚¬ã‚¤ãƒ‰

BUD ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ­ã‚°ç®¡ç†æ–¹é‡ã€ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã€ç›£æŸ»è¦ä»¶ã€åˆ†ææ‰‹æ³•ã‚’å®šç¾©ã—ã¾ã™ã€‚

## ğŸ¯ ãƒ­ã‚°è¨­è¨ˆã®ç›®çš„ãƒ»æ–¹é‡

### åŸºæœ¬æ–¹é‡

- **é€æ˜æ€§**: ã‚·ã‚¹ãƒ†ãƒ ã®å‹•ä½œçŠ¶æ³ã‚’å¯è¦–åŒ–
- **è¿½è·¡å¯èƒ½æ€§**: å•é¡Œã®åŸå› ã‚’è¿…é€Ÿã«ç‰¹å®š
- **ç›£æŸ»å¯¾å¿œ**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹è¦ä»¶ã‚’æº€ãŸã™
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: ãƒ­ã‚°å‡ºåŠ›ãŒã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½ã«ä¸ãˆã‚‹å½±éŸ¿ã‚’æœ€å°åŒ–
- **ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·**: å€‹äººæƒ…å ±ãƒ»éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®é©åˆ‡ãªä¿è­·

### ãƒ­ã‚°åˆ†é¡

| ãƒ­ã‚°ç¨®åˆ¥                 | ç›®çš„                 | ä¿å­˜æœŸé–“ | é‡è¦åº¦ |
| ------------------------ | -------------------- | -------- | ------ |
| **ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚°** | æ¥­å‹™å‡¦ç†ã®è¨˜éŒ²       | 6 ã‹æœˆ   | é«˜     |
| **ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°**         | API å‘¼ã³å‡ºã—å±¥æ­´     | 3 ã‹æœˆ   | ä¸­     |
| **ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°**           | ã‚·ã‚¹ãƒ†ãƒ éšœå®³ãƒ»ä¾‹å¤–   | 1 å¹´     | é«˜     |
| **ç›£æŸ»ãƒ­ã‚°**             | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢é€£æ“ä½œ | 2 å¹´     | æœ€é«˜   |
| **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ­ã‚°**   | æ€§èƒ½ç›£è¦–ãƒ‡ãƒ¼ã‚¿       | 1 ã‹æœˆ   | ä¸­     |
| **éŸ³å£°å‡¦ç†ãƒ­ã‚°**         | éŸ³å£°æ©Ÿèƒ½åˆ©ç”¨å±¥æ­´     | 3 ã‹æœˆ   | é«˜     |

---

## ğŸ“Š ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«å®šç¾©

### æ¨™æº–ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«

| ãƒ¬ãƒ™ãƒ«    | ç”¨é€”                       | å‡ºåŠ›ç’°å¢ƒ           | ä¾‹                                     |
| --------- | -------------------------- | ------------------ | -------------------------------------- |
| **ERROR** | ã‚·ã‚¹ãƒ†ãƒ éšœå®³ãƒ»é‡å¤§ãªã‚¨ãƒ©ãƒ¼ | å…¨ç’°å¢ƒ             | ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šå¤±æ•—ã€API å‘¼ã³å‡ºã—å¤±æ•— |
| **WARN**  | è­¦å‘Šãƒ»æ½œåœ¨çš„ãªå•é¡Œ         | å…¨ç’°å¢ƒ             | ãƒªãƒˆãƒ©ã‚¤å‡¦ç†ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹é…å»¶           |
| **INFO**  | é‡è¦ãªæ¥­å‹™å‡¦ç†             | å…¨ç’°å¢ƒ             | ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã€ä¼šè©±ä½œæˆã€éŸ³å£°å¤‰æ›å®Œäº†   |
| **DEBUG** | é–‹ç™ºãƒ»ãƒ‡ãƒãƒƒã‚°ç”¨è©³ç´°æƒ…å ±   | é–‹ç™ºãƒ»ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚° | é–¢æ•°ã®å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã€SQL å®Ÿè¡Œå†…å®¹       |
| **TRACE** | æœ€è©³ç´°ãƒ¬ãƒ™ãƒ«               | é–‹ç™ºã®ã¿           | è©³ç´°ãªå‡¦ç†ãƒ•ãƒ­ãƒ¼                       |

### ç’°å¢ƒåˆ¥ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«è¨­å®š

```bash
# æœ¬ç•ªç’°å¢ƒ
LOG_LEVEL=INFO

# ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒ
LOG_LEVEL=DEBUG

# é–‹ç™ºç’°å¢ƒ
LOG_LEVEL=TRACE
```

---

## ğŸ–¥ï¸ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ ãƒ­ã‚°è¨­è¨ˆ

### ãƒ­ã‚°å®Ÿè£…ä¾‹

#### 1. ãƒ­ã‚°åŸºç›¤ã‚¯ãƒ©ã‚¹

```typescript
// utils/logger.ts
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
  TRACE = 4,
}

export class Logger {
  private static level: LogLevel =
    process.env.NODE_ENV === "production" ? LogLevel.INFO : LogLevel.DEBUG;

  static error(message: string, error?: Error, context?: any): void {
    if (this.level >= LogLevel.ERROR) {
      const logData = this.createLogData("ERROR", message, error, context);
      console.error(logData);

      // æœ¬ç•ªç’°å¢ƒã§ã¯å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã«é€ä¿¡
      if (process.env.NODE_ENV === "production") {
        this.sendToLoggingService(logData);
      }
    }
  }

  static warn(message: string, context?: any): void {
    if (this.level >= LogLevel.WARN) {
      const logData = this.createLogData("WARN", message, undefined, context);
      console.warn(logData);
    }
  }

  static info(message: string, context?: any): void {
    if (this.level >= LogLevel.INFO) {
      const logData = this.createLogData("INFO", message, undefined, context);
      console.info(logData);
    }
  }

  static debug(message: string, context?: any): void {
    if (this.level >= LogLevel.DEBUG) {
      const logData = this.createLogData("DEBUG", message, undefined, context);
      console.debug(logData);
    }
  }

  private static createLogData(
    level: string,
    message: string,
    error?: Error,
    context?: any
  ) {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      error: error
        ? {
            name: error.name,
            message: error.message,
            stack: error.stack,
          }
        : undefined,
      context,
      url: typeof window !== "undefined" ? window.location.href : undefined,
      userAgent:
        typeof navigator !== "undefined" ? navigator.userAgent : undefined,
      sessionId: this.getSessionId(),
    };
  }

  private static getSessionId(): string {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã®å–å¾—ï¼ˆãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã«é…æ…®ï¼‰
    return sessionStorage.getItem("sessionId") || "anonymous";
  }

  private static async sendToLoggingService(logData: any): Promise<void> {
    try {
      await fetch("/api/logs", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(logData),
      });
    } catch (error) {
      // ãƒ­ã‚°é€ä¿¡å¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      console.error("Failed to send log to service:", error);
    }
  }
}
```

#### 2. æ¥­å‹™ãƒ­ã‚°ã®å®Ÿè£…ä¾‹

```typescript
// components/VoiceRecorder.tsx
import { Logger } from "@/utils/logger";

export function VoiceRecorder() {
  const startRecording = async () => {
    try {
      Logger.info("éŸ³å£°éŒ²éŸ³é–‹å§‹", {
        feature: "voice_recording",
        action: "start",
      });

      // éŸ³å£°éŒ²éŸ³å‡¦ç†
      const recognition = new (window as any).webkitSpeechRecognition();
      recognition.start();

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        Logger.info("éŸ³å£°èªè­˜å®Œäº†", {
          feature: "voice_recognition",
          action: "completed",
          textLength: transcript.length,
          confidence: event.results[0][0].confidence,
        });
      };

      recognition.onerror = (event) => {
        Logger.error("éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼", new Error(event.error), {
          feature: "voice_recognition",
          errorType: event.error,
        });
      };
    } catch (error) {
      Logger.error("éŸ³å£°éŒ²éŸ³é–‹å§‹å¤±æ•—", error as Error, {
        feature: "voice_recording",
      });
    }
  };
}
```

#### 3. API å‘¼ã³å‡ºã—ãƒ­ã‚°

```typescript
// utils/api-client.ts
import { Logger } from "@/utils/logger";

export class ApiClient {
  static async request<T>(url: string, options: RequestInit = {}): Promise<T> {
    const startTime = performance.now();
    const requestId = crypto.randomUUID();

    Logger.debug("APIå‘¼ã³å‡ºã—é–‹å§‹", {
      requestId,
      method: options.method || "GET",
      url,
      timestamp: new Date().toISOString(),
    });

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          "Content-Type": "application/json",
          "X-Request-ID": requestId,
          ...options.headers,
        },
      });

      const duration = performance.now() - startTime;

      if (!response.ok) {
        Logger.warn("APIå‘¼ã³å‡ºã—å¤±æ•—", {
          requestId,
          url,
          status: response.status,
          statusText: response.statusText,
          duration: `${duration.toFixed(2)}ms`,
        });
        throw new Error(`API Error: ${response.status}`);
      }

      Logger.info("APIå‘¼ã³å‡ºã—æˆåŠŸ", {
        requestId,
        url,
        status: response.status,
        duration: `${duration.toFixed(2)}ms`,
      });

      return await response.json();
    } catch (error) {
      const duration = performance.now() - startTime;
      Logger.error("APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼", error as Error, {
        requestId,
        url,
        duration: `${duration.toFixed(2)}ms`,
      });
      throw error;
    }
  }
}
```

---

## âš¡ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ ãƒ­ã‚°è¨­è¨ˆ

### ãƒ­ã‚°å®Ÿè£…ä¾‹

#### 1. ãƒ­ã‚°è¨­å®šï¼ˆFastAPIï¼‰

```python
# utils/logger.py
import logging
import json
from datetime import datetime
from typing import Any, Dict, Optional
import uuid
from contextvars import ContextVar

# ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ç®¡ç†
request_id_var: ContextVar[str] = ContextVar('request_id', default='')

class BudLogger:
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)

        # JSONå½¢å¼ã§ãƒ­ã‚°å‡ºåŠ›
        handler = logging.StreamHandler()
        formatter = JsonFormatter()
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def _create_log_data(self, level: str, message: str, **kwargs) -> Dict[str, Any]:
        return {
            'timestamp': datetime.utcnow().isoformat(),
            'level': level,
            'message': message,
            'request_id': request_id_var.get(),
            'service': 'bud-backend',
            **kwargs
        }

    def info(self, message: str, **kwargs):
        log_data = self._create_log_data('INFO', message, **kwargs)
        self.logger.info(json.dumps(log_data, ensure_ascii=False))

    def error(self, message: str, error: Optional[Exception] = None, **kwargs):
        log_data = self._create_log_data('ERROR', message, **kwargs)
        if error:
            log_data['error'] = {
                'type': type(error).__name__,
                'message': str(error),
                'traceback': traceback.format_exc()
            }
        self.logger.error(json.dumps(log_data, ensure_ascii=False))

    def warn(self, message: str, **kwargs):
        log_data = self._create_log_data('WARN', message, **kwargs)
        self.logger.warning(json.dumps(log_data, ensure_ascii=False))

class JsonFormatter(logging.Formatter):
    def format(self, record):
        return record.getMessage()

# ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
logger = BudLogger(__name__)
```

#### 2. ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã§ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚°

```python
# middleware/logging_middleware.py
import time
import uuid
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
from utils.logger import logger, request_id_var

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDç”Ÿæˆ
        request_id = str(uuid.uuid4())
        request_id_var.set(request_id)

        start_time = time.time()

        # ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹ãƒ­ã‚°
        logger.info("ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–‹å§‹",
            method=request.method,
            url=str(request.url),
            client_ip=request.client.host,
            user_agent=request.headers.get("user-agent", ""),
            request_id=request_id
        )

        try:
            response = await call_next(request)

            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“è¨ˆç®—
            process_time = time.time() - start_time

            # ãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†ãƒ­ã‚°
            logger.info("ãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Œäº†",
                method=request.method,
                url=str(request.url),
                status_code=response.status_code,
                process_time_ms=round(process_time * 1000, 2),
                request_id=request_id
            )

            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDã‚’è¿½åŠ 
            response.headers["X-Request-ID"] = request_id

            return response

        except Exception as e:
            process_time = time.time() - start_time

            logger.error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼",
                error=e,
                method=request.method,
                url=str(request.url),
                process_time_ms=round(process_time * 1000, 2),
                request_id=request_id
            )
            raise
```

#### 3. æ¥­å‹™ãƒ­ã‚¸ãƒƒã‚¯ã§ã®ãƒ­ã‚°å®Ÿè£…ä¾‹

```python
# services/conversation_service.py
from utils.logger import logger
from models.conversation import Conversation

class ConversationService:
    def __init__(self, db: Session):
        self.db = db

    async def create_conversation(self, user_id: int, title: str) -> Conversation:
        logger.info("ä¼šè©±ä½œæˆé–‹å§‹",
            user_id=user_id,
            title=title,
            action="conversation_create_start"
        )

        try:
            conversation = Conversation(
                user_id=user_id,
                title=title,
                created_at=datetime.utcnow()
            )

            self.db.add(conversation)
            self.db.commit()
            self.db.refresh(conversation)

            logger.info("ä¼šè©±ä½œæˆå®Œäº†",
                user_id=user_id,
                conversation_id=conversation.id,
                title=title,
                action="conversation_create_success"
            )

            return conversation

        except Exception as e:
            self.db.rollback()
            logger.error("ä¼šè©±ä½œæˆå¤±æ•—",
                error=e,
                user_id=user_id,
                title=title,
                action="conversation_create_error"
            )
            raise

    async def process_voice_message(self, conversation_id: int, audio_data: bytes) -> str:
        logger.info("éŸ³å£°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†é–‹å§‹",
            conversation_id=conversation_id,
            audio_size_bytes=len(audio_data),
            action="voice_processing_start"
        )

        try:
            # éŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
            text = await self._transcribe_audio(audio_data)

            logger.info("éŸ³å£°å¤‰æ›å®Œäº†",
                conversation_id=conversation_id,
                text_length=len(text),
                action="voice_transcription_success"
            )

            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã—ã¦ä¿å­˜
            message = await self._save_message(conversation_id, text, "voice")

            logger.info("éŸ³å£°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿å­˜å®Œäº†",
                conversation_id=conversation_id,
                message_id=message.id,
                action="voice_message_saved"
            )

            return text

        except Exception as e:
            logger.error("éŸ³å£°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†å¤±æ•—",
                error=e,
                conversation_id=conversation_id,
                action="voice_processing_error"
            )
            raise
```

---

## ğŸ”’ ç›£æŸ»ãƒ­ã‚°è¨­è¨ˆ

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢é€£æ“ä½œã®è¨˜éŒ²

#### 1. èªè¨¼ãƒ»èªå¯ãƒ­ã‚°

```python
# services/auth_service.py
from utils.logger import logger

class AuthService:
    async def login(self, email: str, password: str) -> Dict[str, Any]:
        logger.info("ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œ",
            email=email,
            action="login_attempt",
            audit=True  # ç›£æŸ»ãƒ­ã‚°ãƒ•ãƒ©ã‚°
        )

        try:
            # Firebaseèªè¨¼å‡¦ç†
            user = await self._authenticate_user(email, password)

            logger.info("ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ",
                user_id=user.id,
                email=email,
                action="login_success",
                audit=True
            )

            return {"user": user, "token": "..."}

        except AuthenticationError as e:
            logger.warn("ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—",
                email=email,
                error_type="authentication_failed",
                action="login_failure",
                audit=True
            )
            raise

    async def logout(self, user_id: int):
        logger.info("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ",
            user_id=user_id,
            action="logout",
            audit=True
        )
```

#### 2. ãƒ‡ãƒ¼ã‚¿æ“ä½œç›£æŸ»ãƒ­ã‚°

```python
# services/message_service.py
class MessageService:
    async def delete_message(self, user_id: int, message_id: int):
        message = await self._get_message(message_id)

        # å‰Šé™¤å‰ã®ç›£æŸ»ãƒ­ã‚°
        logger.info("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤",
            user_id=user_id,
            message_id=message_id,
            conversation_id=message.conversation_id,
            message_content_length=len(message.content),
            action="message_delete",
            audit=True
        )

        await self._delete_message(message_id)

    async def update_message(self, user_id: int, message_id: int, new_content: str):
        old_message = await self._get_message(message_id)

        logger.info("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ›´æ–°",
            user_id=user_id,
            message_id=message_id,
            old_content_length=len(old_message.content),
            new_content_length=len(new_content),
            action="message_update",
            audit=True
        )

        await self._update_message(message_id, new_content)
```

---

## ğŸ¤ éŸ³å£°æ©Ÿèƒ½å°‚ç”¨ãƒ­ã‚°

### éŸ³å£°å‡¦ç†ã®è©³ç´°ãƒ­ã‚°

```python
# services/voice_service.py
class VoiceService:
    async def transcribe_audio(self, audio_data: bytes, user_id: int) -> str:
        audio_info = {
            'size_bytes': len(audio_data),
            'duration_estimate': self._estimate_duration(audio_data),
            'format': self._detect_audio_format(audio_data)
        }

        logger.info("éŸ³å£°å¤‰æ›é–‹å§‹",
            user_id=user_id,
            audio_info=audio_info,
            action="voice_transcription_start",
            feature="voice_processing"
        )

        try:
            # Web Speech API ã¾ãŸã¯ Whisper API
            if self._use_web_speech_api():
                result = await self._transcribe_with_web_speech(audio_data)
                logger.info("Web Speech API å¤‰æ›å®Œäº†",
                    user_id=user_id,
                    result_length=len(result),
                    method="web_speech_api",
                    action="transcription_success"
                )
            else:
                result = await self._transcribe_with_whisper(audio_data)
                logger.info("Whisper API å¤‰æ›å®Œäº†",
                    user_id=user_id,
                    result_length=len(result),
                    method="whisper_api",
                    action="transcription_success"
                )

            # ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ï¼šéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã¯è¨˜éŒ²ã—ãªã„
            logger.info("éŸ³å£°å¤‰æ›çµæœ",
                user_id=user_id,
                transcription_length=len(result),
                audio_duration=audio_info['duration_estimate'],
                quality_score=self._calculate_quality_score(result),
                action="transcription_completed"
            )

            return result

        except Exception as e:
            logger.error("éŸ³å£°å¤‰æ›ã‚¨ãƒ©ãƒ¼",
                error=e,
                user_id=user_id,
                audio_info=audio_info,
                action="transcription_error"
            )
            raise

    def _calculate_quality_score(self, text: str) -> float:
        # å¤‰æ›å“è³ªã®ç°¡æ˜“è©•ä¾¡
        if len(text) == 0:
            return 0.0

        # æ–‡å­—æ•°ã€å¥èª­ç‚¹ã®æœ‰ç„¡ãªã©ã§å“è³ªè©•ä¾¡
        score = min(1.0, len(text) / 100)  # ç°¡æ˜“å®Ÿè£…
        return round(score, 2)
```

---

## ğŸ“ˆ ãƒ­ã‚°åˆ†æãƒ»ç›£è¦–

### 1. ãƒ­ã‚°é›†ç´„ãƒ»å¯è¦–åŒ–

#### Elasticsearch + Kibana é¢¨ã®è¨­å®šä¾‹

```yaml
# docker-compose.yml (å°†æ¥çš„ãªæ‹¡å¼µç”¨)
version: "3.8"
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"

  kibana:
    image: docker.elastic.co/kibana/kibana:8.5.0
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch

  logstash:
    image: docker.elastic.co/logstash/logstash:8.5.0
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline
    depends_on:
      - elasticsearch
```

#### ãƒ­ã‚°è»¢é€è¨­å®š

```python
# utils/log_shipper.py
import asyncio
import aiohttp
from typing import Dict, Any

class LogShipper:
    def __init__(self, elasticsearch_url: str):
        self.elasticsearch_url = elasticsearch_url

    async def ship_log(self, log_data: Dict[str, Any]):
        """ãƒ­ã‚°ã‚’Elasticsearchã«é€ä¿¡"""
        if not self._should_ship_log(log_data):
            return

        try:
            async with aiohttp.ClientSession() as session:
                await session.post(
                    f"{self.elasticsearch_url}/bud-logs/_doc",
                    json=log_data,
                    timeout=aiohttp.ClientTimeout(total=5)
                )
        except Exception as e:
            # ãƒ­ã‚°é€ä¿¡å¤±æ•—æ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ­ã‚°ã«è¨˜éŒ²
            print(f"Failed to ship log: {e}")

    def _should_ship_log(self, log_data: Dict[str, Any]) -> bool:
        """é€ä¿¡ã™ã¹ããƒ­ã‚°ã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
        # æœ¬ç•ªç’°å¢ƒã®ã¿ã€ã¾ãŸã¯é‡è¦åº¦ã®é«˜ã„ãƒ­ã‚°ã®ã¿é€ä¿¡
        return (
            log_data.get('level') in ['ERROR', 'WARN'] or
            log_data.get('audit') is True or
            log_data.get('feature') == 'voice_processing'
        )
```

### 2. ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š

#### é‡è¦ãªãƒ­ã‚°ã‚¤ãƒ™ãƒ³ãƒˆã®ç›£è¦–

```python
# utils/log_alerting.py
from typing import Dict, Any
import asyncio

class LogAlertManager:
    def __init__(self):
        self.alert_rules = [
            {
                'name': 'high_error_rate',
                'condition': lambda logs: self._check_error_rate(logs) > 0.05,
                'action': self._send_slack_alert
            },
            {
                'name': 'voice_processing_failure',
                'condition': lambda logs: self._check_voice_failures(logs) > 5,
                'action': self._send_urgent_alert
            }
        ]

    async def process_log(self, log_data: Dict[str, Any]):
        """ãƒ­ã‚°ã‚’å—ä¿¡ã—ã¦ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯"""
        for rule in self.alert_rules:
            if await self._evaluate_rule(rule, log_data):
                await rule['action'](rule['name'], log_data)

    def _check_error_rate(self, recent_logs: list) -> float:
        if not recent_logs:
            return 0.0

        error_count = sum(1 for log in recent_logs if log.get('level') == 'ERROR')
        return error_count / len(recent_logs)

    async def _send_slack_alert(self, rule_name: str, log_data: Dict[str, Any]):
        # Slacké€šçŸ¥ã®å®Ÿè£…
        pass
```

---

## ğŸ”§ ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ä¿å­˜

### ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†

#### 1. ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š

```python
# utils/log_rotation.py
import logging.handlers
import os
from datetime import datetime

def setup_rotating_logger(name: str, log_file: str, max_bytes: int = 10485760, backup_count: int = 5):
    """ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ä»˜ããƒ­ã‚¬ãƒ¼è¨­å®š"""

    # ãƒ­ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
    log_dir = os.path.dirname(log_file)
    os.makedirs(log_dir, exist_ok=True)

    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)

    # ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=max_bytes,  # 10MB
        backupCount=backup_count
    )

    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)

    logger.addHandler(handler)
    return logger

# ä½¿ç”¨ä¾‹
app_logger = setup_rotating_logger('bud.app', '/var/log/bud/app.log')
audit_logger = setup_rotating_logger('bud.audit', '/var/log/bud/audit.log')
```

#### 2. ãƒ­ã‚°ä¿å­˜æœŸé–“ç®¡ç†

```python
# utils/log_cleanup.py
import os
import time
from datetime import datetime, timedelta

class LogCleanupManager:
    def __init__(self, log_directory: str):
        self.log_directory = log_directory
        self.retention_policies = {
            'app.log': timedelta(days=180),      # 6ã‹æœˆ
            'audit.log': timedelta(days=730),    # 2å¹´
            'error.log': timedelta(days=365),    # 1å¹´
            'access.log': timedelta(days=90),    # 3ã‹æœˆ
        }

    def cleanup_old_logs(self):
        """ä¿å­˜æœŸé–“ã‚’éããŸãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤"""
        for log_pattern, retention_period in self.retention_policies.items():
            cutoff_time = datetime.now() - retention_period

            for filename in os.listdir(self.log_directory):
                if log_pattern in filename:
                    file_path = os.path.join(self.log_directory, filename)
                    file_time = datetime.fromtimestamp(os.path.getmtime(file_path))

                    if file_time < cutoff_time:
                        os.remove(file_path)
                        print(f"Deleted old log file: {filename}")

# å®šæœŸå®Ÿè¡Œè¨­å®šï¼ˆcronç­‰ã§å®Ÿè¡Œï¼‰
if __name__ == "__main__":
    cleanup_manager = LogCleanupManager('/var/log/bud')
    cleanup_manager.cleanup_old_logs()
```

---

## ğŸ” ãƒ­ã‚°åˆ†æãƒ»ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ä¸€èˆ¬çš„ãªåˆ†æã‚¯ã‚¨ãƒªä¾‹

#### 1. ã‚¨ãƒ©ãƒ¼åˆ†æ

```bash
# éå»1æ™‚é–“ã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’æ™‚ç³»åˆ—ã§è¡¨ç¤º
grep "ERROR" /var/log/bud/app.log | grep "$(date -d '1 hour ago' '+%Y-%m-%d %H')"

# ç‰¹å®šã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã®ç™ºç”Ÿé »åº¦
grep "voice_processing_error" /var/log/bud/app.log | wc -l

# ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¥ã‚¨ãƒ©ãƒ¼é›†è¨ˆ
grep "ERROR" /var/log/bud/app.log | jq -r '.user_id' | sort | uniq -c | sort -nr
```

#### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ

```bash
# ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãŒé•·ã„APIã‚³ãƒ¼ãƒ«
grep "process_time_ms" /var/log/bud/app.log | jq 'select(.process_time_ms > 1000)'

# éŸ³å£°å‡¦ç†ã®å‡¦ç†æ™‚é–“åˆ†æ
grep "voice_transcription" /var/log/bud/app.log | jq '.process_time_ms' | sort -n
```

#### 3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»

```bash
# ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã®ç›£è¦–
grep "login_failure" /var/log/bud/audit.log | tail -20

# ç•°å¸¸ãªã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
grep "request_id" /var/log/bud/access.log | jq -r '.client_ip' | sort | uniq -c | sort -nr | head -10
```

---

## ğŸ“‹ ãƒ­ã‚°é‹ç”¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### é–‹ç™ºæ™‚ã®ãƒã‚§ãƒƒã‚¯é …ç›®

- [ ] é©åˆ‡ãªãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®šã—ã¦ã„ã‚‹
- [ ] å€‹äººæƒ…å ±ãƒ»æ©Ÿå¯†æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›ã—ã¦ã„ãªã„
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã§ãƒ­ã‚°å‡ºåŠ›ã—ã¦ã„ã‚‹
- [ ] é‡è¦ãªæ¥­å‹™å‡¦ç†ã§ãƒ­ã‚°å‡ºåŠ›ã—ã¦ã„ã‚‹
- [ ] ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¤œç´¢ãƒ»åˆ†æã—ã‚„ã™ã„å½¢å¼

### æœ¬ç•ªé‹ç”¨æ™‚ã®ãƒã‚§ãƒƒã‚¯é …ç›®

- [ ] ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã‚‹
- [ ] ãƒ‡ã‚£ã‚¹ã‚¯å®¹é‡ãŒé€¼è¿«ã—ã¦ã„ãªã„
- [ ] é‡è¦ãªã‚¢ãƒ©ãƒ¼ãƒˆãŒé©åˆ‡ã«é€šçŸ¥ã•ã‚Œã¦ã„ã‚‹
- [ ] ç›£æŸ»ãƒ­ã‚°ãŒæ”¹ã–ã‚“ã•ã‚Œã¦ã„ãªã„
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒæ­£å¸¸ã«å–å¾—ã•ã‚Œã¦ã„ã‚‹

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯é …ç›®

- [ ] ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] ç›£æŸ»ãƒ­ã‚°ã®å®Œå…¨æ€§ãŒä¿ãŸã‚Œã¦ã„ã‚‹
- [ ] ãƒ­ã‚°ã®æ”¹ã–ã‚“æ¤œçŸ¥æ©Ÿèƒ½ãŒå‹•ä½œã—ã¦ã„ã‚‹
- [ ] æ©Ÿå¯†æƒ…å ±ã®æ¼æ´©ãŒãƒ­ã‚°ã«å«ã¾ã‚Œã¦ã„ãªã„
- [ ] ãƒ­ã‚°è»¢é€æ™‚ã®æš—å·åŒ–ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹

---

## ğŸš¨ éšœå®³æ™‚ã®ãƒ­ã‚°æ´»ç”¨

### éšœå®³èª¿æŸ»ã®æ‰‹é †

#### 1. åˆæœŸèª¿æŸ»

```bash
# éšœå®³ç™ºç”Ÿæ™‚åˆ»å‘¨è¾ºã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’ç¢ºèª
grep "ERROR\|WARN" /var/log/bud/app.log | grep "2025-08-04 14:"

# ç‰¹å®šã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDã§é–¢é€£ãƒ­ã‚°ã‚’è¿½è·¡
grep "request_id:abc-123-def" /var/log/bud/*.log

# ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨çŠ¶æ³ã®ç¢ºèª
grep "memory\|cpu\|disk" /var/log/bud/system.log
```

#### 2. è©³ç´°åˆ†æ

```python
# scripts/log_analyzer.py
import json
from datetime import datetime, timedelta
from collections import defaultdict

class LogAnalyzer:
    def __init__(self, log_file_path: str):
        self.log_file_path = log_file_path

    def analyze_error_timeline(self, start_time: datetime, end_time: datetime):
        """æŒ‡å®šæœŸé–“ã®ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’åˆ†æ"""
        errors = []

        with open(self.log_file_path, 'r') as f:
            for line in f:
                try:
                    log_data = json.loads(line)
                    log_time = datetime.fromisoformat(log_data['timestamp'])

                    if (start_time <= log_time <= end_time and
                        log_data.get('level') == 'ERROR'):
                        errors.append(log_data)
                except:
                    continue

        # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—åˆ¥é›†è¨ˆ
        error_types = defaultdict(int)
        for error in errors:
            error_type = error.get('error', {}).get('type', 'Unknown')
            error_types[error_type] += 1

        return {
            'total_errors': len(errors),
            'error_types': dict(error_types),
            'timeline': sorted(errors, key=lambda x: x['timestamp'])
        }

    def find_performance_bottlenecks(self, threshold_ms: int = 1000):
        """æ€§èƒ½ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã®ç‰¹å®š"""
        slow_requests = []

        with open(self.log_file_path, 'r') as f:
            for line in f:
                try:
                    log_data = json.loads(line)
                    process_time = log_data.get('process_time_ms', 0)

                    if process_time > threshold_ms:
                        slow_requests.append({
                            'timestamp': log_data['timestamp'],
                            'url': log_data.get('url', ''),
                            'process_time_ms': process_time,
                            'request_id': log_data.get('request_id', '')
                        })
                except:
                    continue

        return sorted(slow_requests, key=lambda x: x['process_time_ms'], reverse=True)
```

### ç·Šæ€¥æ™‚ã®å¯¾å¿œãƒ•ãƒ­ãƒ¼

#### 1. ã‚¢ãƒ©ãƒ¼ãƒˆå—ä¿¡æ™‚ã®å¯¾å¿œ

```python
# utils/emergency_response.py
class EmergencyResponseManager:
    def __init__(self):
        self.response_procedures = {
            'high_error_rate': self._handle_high_error_rate,
            'system_down': self._handle_system_down,
            'security_breach': self._handle_security_breach,
            'voice_service_failure': self._handle_voice_service_failure
        }

    async def handle_alert(self, alert_type: str, alert_data: dict):
        """ã‚¢ãƒ©ãƒ¼ãƒˆç¨®åˆ¥ã«å¿œã˜ãŸå¯¾å¿œã‚’å®Ÿè¡Œ"""
        if alert_type in self.response_procedures:
            await self.response_procedures[alert_type](alert_data)
        else:
            await self._handle_unknown_alert(alert_type, alert_data)

    async def _handle_high_error_rate(self, alert_data: dict):
        """é«˜ã‚¨ãƒ©ãƒ¼ç‡ã®å¯¾å¿œ"""
        # 1. ç¾åœ¨ã®ã‚¨ãƒ©ãƒ¼çŠ¶æ³ã‚’è©³ç´°åˆ†æ
        # 2. å½±éŸ¿ç¯„å›²ã®ç‰¹å®š
        # 3. ç·Šæ€¥åº¦ã®åˆ¤å®š
        # 4. é–¢ä¿‚è€…ã¸ã®é€šçŸ¥
        pass

    async def _handle_voice_service_failure(self, alert_data: dict):
        """éŸ³å£°ã‚µãƒ¼ãƒ“ã‚¹éšœå®³ã®å¯¾å¿œ"""
        # 1. éŸ³å£°å‡¦ç†ã‚­ãƒ¥ãƒ¼ã®çŠ¶æ³ç¢ºèª
        # 2. å¤–éƒ¨APIï¼ˆWhisperï¼‰ã®çŠ¶æ³ç¢ºèª
        # 3. Web Speech API ã¸ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œè¨
        # 4. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®å½±éŸ¿é€šçŸ¥
        pass
```

---

## ğŸ“Š ãƒ­ã‚°ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ»KPI

### ç›£è¦–ã™ã¹ããƒ¡ãƒˆãƒªã‚¯ã‚¹

#### 1. ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹æŒ‡æ¨™

| ãƒ¡ãƒˆãƒªã‚¯ã‚¹             | ç›®æ¨™å€¤   | ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶ |
| ---------------------- | -------- | ------------ |
| **ã‚¨ãƒ©ãƒ¼ç‡**           | < 0.1%   | > 1%         |
| **å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“** | < 200ms  | > 500ms      |
| **ãƒ­ã‚°å‡ºåŠ›é‡**         | < 1GB/æ—¥ | > 5GB/æ—¥     |
| **ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡**     | < 80%    | > 90%        |

#### 2. æ©Ÿèƒ½åˆ¥ãƒ¡ãƒˆãƒªã‚¯ã‚¹

| æ©Ÿèƒ½             | ãƒ¡ãƒˆãƒªã‚¯ã‚¹   | ç›®æ¨™å€¤  |
| ---------------- | ------------ | ------- |
| **éŸ³å£°èªè­˜**     | æˆåŠŸç‡       | > 95%   |
| **éŸ³å£°èªè­˜**     | å¹³å‡å‡¦ç†æ™‚é–“ | < 2 ç§’  |
| **API èªè¨¼**     | å¤±æ•—ç‡       | < 0.1%  |
| **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹** | æ¥ç¶šã‚¨ãƒ©ãƒ¼ç‡ | < 0.01% |

#### 3. ãƒ“ã‚¸ãƒã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹

```python
# utils/business_metrics.py
class BusinessMetricsCollector:
    def __init__(self, log_analyzer):
        self.log_analyzer = log_analyzer

    def calculate_daily_metrics(self, date: str) -> dict:
        """æ—¥æ¬¡ãƒ“ã‚¸ãƒã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ç®—å‡º"""
        return {
            'active_users': self._count_active_users(date),
            'conversations_created': self._count_conversations(date),
            'voice_messages_processed': self._count_voice_messages(date),
            'average_session_duration': self._calculate_session_duration(date),
            'feature_usage': self._analyze_feature_usage(date)
        }

    def _count_voice_messages(self, date: str) -> int:
        """éŸ³å£°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ"""
        count = 0
        with open(self.log_file_path, 'r') as f:
            for line in f:
                try:
                    log_data = json.loads(line)
                    if (log_data.get('action') == 'voice_transcription_success' and
                        log_data['timestamp'].startswith(date)):
                        count += 1
                except:
                    continue
        return count
```

---

## ğŸ” ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒ»GDPR å¯¾å¿œ

### å€‹äººæƒ…å ±ã®å–ã‚Šæ‰±ã„

#### 1. ãƒ­ã‚°ã§ã®å€‹äººæƒ…å ±ä¿è­·

```python
# utils/privacy_filter.py
import re
from typing import Dict, Any

class PrivacyFilter:
    def __init__(self):
        self.patterns = {
            'email': re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'),
            'phone': re.compile(r'\b\d{3}-\d{3,4}-\d{4}\b'),
            'ip_address': re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
        }

    def sanitize_log_data(self, log_data: Dict[str, Any]) -> Dict[str, Any]:
        """ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å€‹äººæƒ…å ±ã‚’é™¤å»ãƒ»ãƒã‚¹ã‚¯"""
        sanitized = log_data.copy()

        # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹ã®ãƒã‚¹ã‚¯
        if 'message' in sanitized:
            sanitized['message'] = self._mask_sensitive_data(sanitized['message'])

        # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒã‚¹ã‚¯
        if 'error' in sanitized and 'message' in sanitized['error']:
            sanitized['error']['message'] = self._mask_sensitive_data(
                sanitized['error']['message']
            )

        # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®éƒ¨åˆ†ãƒã‚¹ã‚¯ï¼ˆæœ€å¾Œã®ã‚ªã‚¯ãƒ†ãƒƒãƒˆã‚’éš ã™ï¼‰
        if 'client_ip' in sanitized:
            sanitized['client_ip'] = self._mask_ip_address(sanitized['client_ip'])

        return sanitized

    def _mask_sensitive_data(self, text: str) -> str:
        """æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¹ã‚¯ã™ã‚‹"""
        masked_text = text

        for pattern_name, pattern in self.patterns.items():
            if pattern_name == 'email':
                masked_text = pattern.sub('***@***.com', masked_text)
            elif pattern_name == 'phone':
                masked_text = pattern.sub('***-****-****', masked_text)

        return masked_text

    def _mask_ip_address(self, ip: str) -> str:
        """IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’éƒ¨åˆ†çš„ã«ãƒã‚¹ã‚¯"""
        parts = ip.split('.')
        if len(parts) == 4:
            return f"{parts[0]}.{parts[1]}.{parts[2]}.***"
        return ip
```

#### 2. ãƒ‡ãƒ¼ã‚¿å‰Šé™¤è¦æ±‚ã¸ã®å¯¾å¿œ

```python
# utils/data_deletion.py
class DataDeletionManager:
    def __init__(self, log_directory: str):
        self.log_directory = log_directory

    async def delete_user_logs(self, user_id: int):
        """ç‰¹å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤"""
        log_files = self._get_all_log_files()

        for log_file in log_files:
            await self._remove_user_data_from_log(log_file, user_id)

    async def _remove_user_data_from_log(self, log_file: str, user_id: int):
        """ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç‰¹å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’é™¤å»"""
        temp_file = f"{log_file}.temp"

        with open(log_file, 'r') as infile, open(temp_file, 'w') as outfile:
            for line in infile:
                try:
                    log_data = json.loads(line)
                    if log_data.get('user_id') != user_id:
                        outfile.write(line)
                except:
                    # JSONä»¥å¤–ã®ãƒ­ã‚°è¡Œã¯ãã®ã¾ã¾ä¿æŒ
                    outfile.write(line)

        # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®æ›
        os.replace(temp_file, log_file)
```

---

## ğŸ”§ é–‹ç™ºãƒ»é‹ç”¨ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

### é–‹ç™ºè€…å‘ã‘ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

#### 1. ãƒ­ã‚°å®Ÿè£…ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

```python
# âœ… è‰¯ã„ä¾‹
logger.info("ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²å®Œäº†",
    user_id=user.id,
    registration_method="google_oauth",
    action="user_registration_success"
)

# âŒ æ‚ªã„ä¾‹
logger.info(f"User {user.email} registered successfully")  # å€‹äººæƒ…å ±ã‚’å«ã‚€
print("Something happened")  # æ§‹é€ åŒ–ã•ã‚Œã¦ã„ãªã„
logger.debug("All user data: " + str(user_data))  # éåº¦ãªæƒ…å ±
```

#### 2. ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

```python
# âœ… è‰¯ã„ä¾‹
try:
    result = await external_api_call()
except ExternalAPIError as e:
    logger.error("å¤–éƒ¨APIå‘¼ã³å‡ºã—å¤±æ•—",
        error=e,
        api_endpoint="/api/voice/transcribe",
        retry_count=retry_count,
        action="external_api_error"
    )

# âŒ æ‚ªã„ä¾‹
except Exception as e:
    logger.error("Error occurred")  # æƒ…å ±ä¸è¶³
    logger.error(str(e))  # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸è¶³
```

### é‹ç”¨ãƒãƒ¼ãƒ å‘ã‘ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

#### 1. æ—¥å¸¸ç›£è¦–é …ç›®

- **æ¯æ—¥ç¢ºèª**: ã‚¨ãƒ©ãƒ¼ç‡ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã€ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨é‡
- **é€±æ¬¡ç¢ºèª**: ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ³ã€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†
- **æœˆæ¬¡ç¢ºèª**: ãƒ­ã‚°ä¿å­˜æœŸé–“ã®éµå®ˆã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ç›£æŸ»

#### 2. ç·Šæ€¥æ™‚å¯¾å¿œæ‰‹é †

1. **ã‚¢ãƒ©ãƒ¼ãƒˆå—ä¿¡æ™‚**: 5 åˆ†ä»¥å†…ã«åˆæœŸå¯¾å¿œé–‹å§‹
2. **å½±éŸ¿ç¯„å›²ç‰¹å®š**: ãƒ­ã‚°åˆ†æã«ã‚ˆã‚‹åŸå› èª¿æŸ»
3. **ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: é‡å¤§éšœå®³æ™‚ã®é–¢ä¿‚è€…é€šçŸ¥
4. **å¾©æ—§ä½œæ¥­**: ãƒ­ã‚°ã«ã‚ˆã‚‹å¾©æ—§çŠ¶æ³ç¢ºèª
5. **äº‹å¾Œåˆ†æ**: éšœå®³ã®æ ¹æœ¬åŸå› åˆ†æ

---

## ğŸ“ ã¾ã¨ã‚

### ãƒ­ã‚°è¨­è¨ˆã®é‡è¦ãƒã‚¤ãƒ³ãƒˆ

1. **æ§‹é€ åŒ–ãƒ­ã‚°**: JSON å½¢å¼ã§ã®çµ±ä¸€çš„ãªãƒ­ã‚°å‡ºåŠ›
2. **ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·**: å€‹äººæƒ…å ±ãƒ»æ©Ÿå¯†æƒ…å ±ã®é©åˆ‡ãªä¿è­·
3. **ç›£æŸ»è¨¼è·¡**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢é€£æ“ä½œã®å®Œå…¨ãªè¨˜éŒ²
4. **æ€§èƒ½è€ƒæ…®**: ãƒ­ã‚°å‡ºåŠ›ãŒã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½ã«ä¸ãˆã‚‹å½±éŸ¿ã®æœ€å°åŒ–
5. **é‹ç”¨æ€§**: éšœå®³æ™‚ã®è¿…é€ŸãªåŸå› ç‰¹å®šã¨å¯¾å¿œ

### ç¶™ç¶šçš„æ”¹å–„

- **ãƒ­ã‚°ã®æœ‰åŠ¹æ€§**: å®šæœŸçš„ãªãƒ­ã‚°å‡ºåŠ›å†…å®¹ã®è¦‹ç›´ã—
- **ç›£è¦–ç²¾åº¦**: ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶ã®èª¿æ•´ã¨ false positive ã®å‰Šæ¸›
- **åˆ†æåŠ¹ç‡**: ãƒ­ã‚°åˆ†æãƒ„ãƒ¼ãƒ«ã®æ´»ç”¨ã¨è‡ªå‹•åŒ–
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: ãƒ­ã‚°ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ç¶™ç¶šçš„ãªå¼·åŒ–

**ğŸ¯ é©åˆ‡ãªãƒ­ã‚°è¨­è¨ˆã«ã‚ˆã‚Šã€ã‚·ã‚¹ãƒ†ãƒ ã®é€æ˜æ€§ã¨ä¿¡é ¼æ€§ã‚’å‘ä¸Šã•ã›ã€è¿…é€Ÿãªå•é¡Œè§£æ±ºã¨ã‚µãƒ¼ãƒ“ã‚¹æ”¹å–„ã‚’å®Ÿç¾ã—ã¾ã—ã‚‡ã†ï¼**
